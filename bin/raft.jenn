Node {

    // persistent state
    int self = 0;
    int currentTerm = 0;
    int votedFor = 0;
    List log_command = [];
    List log_term = [];
    List replicas = [];

    // volatile state on servers
    int commitIndex = 0;
    int lastApplied = 0;

    List nextIndex = [];
    List matchIndex = [];

    string state = "FOLLOWER";

    func Init(me, peers) -> none {
        self = me;
        currentTerm = 0;
        votedFor = -1;
        log_command = ["idx0"];
        log_term = [-1];

        commitIndex = 0;
        lastApplied = 0;

        nextIndex = [];
        matchIndex = [];
        replicas = [];

        state = "FOLLOWER";

        for (i = 0; i < len(peers); i = i+1) {
            matchIndex = append(matchIndex, 0);
            replicas = append(replicas, peers[i]);
        }
    }

    func BeginElection(replies, peer, quorum, copyCurrentTerm) -> none {
        currentTerm = currentTerm + 1;
        state = "CANDIDATE";
        votedFor = self;

        replies = {};
        for (i = 0; i < len(replicas); i = i+1) {
            peer = replicas[i];
            if (peer != self) {
                replies[peer] = rpc_async_call(peer, RequestVote(currentTerm, self, -1, -1));
            }
        }

        copyCurrentTerm = currentTerm;
        quorum = 1 - 1 + len(replicas) / 2; // vote for self counts
        for (derp = 0; derp < 10; derp = derp + 1) {
            hee = poll_for_resps(replies, {term: currentTerm, voteGranted: true});
            if (hee != quorum) {
                print(hee);
                print(replies);
            }
        }
        print("WOAHJENN");
        print(quorum);
        print(poll_for_resps(replies, {term: currentTerm, voteGranted: true}) >= quorum);
        await (poll_for_resps(replies, {term: currentTerm, voteGranted: true}) >= quorum) || (votedFor != self) || (currentTerm != copyCurrentTerm);

        if (poll_for_resps(replies, {term: currentTerm, voteGranted: true}) >= quorum) {
            state = "LEADER";
        }

    }

    func RequestVote(term, candidateId, lastLogIndx, lastLogTerm) -> Map {
        if (term < currentTerm) {
            return {term: currentTerm, voteGranted: false};
        } else if (votedFor == -1 || votedFor == candidateId) {
            state = "FOLLOWER";
            votedFor = candidateId;
            currentTerm = term;
            if (term > currentTerm) {
                currentTerm = term;
                state = "FOLLOWER";
            }
            return {term: term, voteGranted: true};
        } else {
            if (term > currentTerm) {
                currentTerm = term;
                state = "FOLLOWER";
            }
            return {term: -1, voteGranted: false};
        }
    }

    func Heartbeat() -> none {
        temp = 1;
    }

}

ClientInterface{
    
    func init(dest, replicas) -> none {
        rpc_call(dest, Init(dest, replicas));
    }

    func beginElection(dest) -> none {
        rpc_call(dest, BeginElection({}, 0, 0, 0));
    }

}