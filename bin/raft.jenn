Node {

    // persistent state
    int self = 0;
    int currentTerm = 0;
    int votedFor = 0;
    List log = [];
    List replicas = [];

    // volatile state on servers
    int commitIndex = 0;
    int lastApplied = 0;

    List nextIndex = [];
    List matchIndex = [];

    string state = "FOLLOWER";

    func Init(me, peers) -> none {

        self = me;
        currentTerm = 0;
        votedFor = -1;
        log = [{"term": 0, "cmd": "WRITE_IDX0"}];

        commitIndex = 0;
        lastApplied = 0;

        nextIndex = [];
        matchIndex = [];
        replicas = [];

        state = "FOLLOWER";

        for (i = 0; i < len(peers); i = i+1) {
            nextIndex = append(nextIndex, 0);
            matchIndex = append(matchIndex, 0);
            replicas = append(replicas, peers[i]);
        }
    }

    func BeginElection() -> none {
        currentTerm = currentTerm + 1;
        state = "CANDIDATE";
        votedFor = self;

        replies = {};
        peer = 0;
        for (i = 0; i < len(replicas); i = i+1) {
            peer = replicas[i];
            if (peer != self) {
                replies[peer] = rpc_async_call(peer, RequestVote(currentTerm, self, -1, -1));
            }
        }

        copyCurrentTerm = currentTerm;
        quorum = 1 - 1 + len(replicas) / 2; // vote for self counts

        // hoisting some variables
        resps_recvd = 0;
        votes = 1;
        any = {};
        ni = 0;
        for (placeholder = 0; resps_recvd < len(replies); placeholder = placeholder + 1) {

            await has_next_resp(replies) || (state != "CANDIDATE") || (currentTerm != copyCurrentTerm);

            if ((state != "CANDIDATE") || (currentTerm != copyCurrentTerm)) {
                // election failed or already restarted
                return 0;
            }

            resps_recvd = resps_recvd + 1;
            any = next_resp(replies);
            if (any["term"] > currentTerm) {
                state = "FOLLOWER";
                return 0;
            } else if (any["voteGranted"]) {
                votes = votes + 1;
                if (votes >= quorum) {
                    state = "LEADER";

                    l = len(log);
                    for (ni = 0; ni < len(replicas); ni = ni + 1) {
                        nextIndex[ni] = l; // initialized to leader last log idx + 1
                        matchIndex[ni] = 0;
                    }
                    return 0;
                } 
            }
        }

        // election failed, restart the election
        BeginElection();
    }

    func BroadcastHeartbeats() -> None {
        prevLogIndex = len(log) - 1;
        prevLogTerm = log[prevLogIndex]["term"];

        log = append(log, {"term": currentTerm, "cmd": "WON_ELECTION"});
        entries = log[prevLogIndex + 1:len(log)];
        print(entries);

        resps = {};
        for (p = 0; p < len(replicas); p = p + 1) {
            peer = replicas[p];
            if (peer != self) {
                resps[peer] = rpc_async_call(peer, 
                    AppendEntries(currentTerm, self, prevLogIndex, prevLogTerm, entries, commitIndex));
            }
        }

        // TODO jenndebug finish the rest of this
    }

    func RequestVote(term, candidateId, lastLogIndx, lastLogTerm) -> Map {
        if (term < currentTerm) {
            return {"term": currentTerm, "voteGranted": false};
        } else if (votedFor == -1 || votedFor == candidateId) {
            state = "FOLLOWER";
            votedFor = candidateId;
            currentTerm = term;
            return {"term": term, "voteGranted": true};
        } else {
            if (term > currentTerm) {
                currentTerm = term;
                state = "FOLLOWER";
            }
            return {"term": -1, "voteGranted": false};
        }
    }

    func AppendEntries(term, leaderId, prevLogIndex, prevLogTerm, entries, leaderCommit) -> Map {
        //return {"term": currentTerm, "success": true}
        
        if (term < currentTerm) {
            return {"term": currentTerm, "success": false};
        } else if (len(log) <= prevLogIndex) {
            return {"term": -1, "success": false};
        } else if (log[prevLogIndex]["term"] != prevLogTerm) {
            log = log[0:prevLogIndex];
            return {"term": -1, "success": false};
        }

        for (i = 0; i < len(entries); i = i + 1) {
            log = append(log, entries[i]);
        }

        // TODO jenndebug need a placeholder here
        return {"term": currentTerm, "success": true};

    }

}

ClientInterface{
    
    func init(dest, replicas) -> none {
        rpc_call(dest, BASE_NODE_INIT());
        rpc_call(dest, Init(dest, replicas));
    }

    func beginElection(dest) -> none {
        rpc_call(dest, BeginElection());
    }

    func broadcastHeartbeats(dest) -> none {
        rpc_call(dest, BroadcastHeartbeats());
    }

}