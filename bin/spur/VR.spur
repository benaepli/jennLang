type Command {
    kind: int; // 0: Read, 1: Write
    key: string;
    value: string?;
};

// Represents a single entry in a replica's log.
type LogEntry {
    view: int;
    op: Command;
};
// Represents the state information sent during a view change.
type DoViewChangeMsg {
    log: list<LogEntry>;
    normal_view: int;
    op_number: int;
    commit_number: int;
};

type ClientResponse {
    is_primary: bool;
    key: string?;
    value: string?;
    primary: Node;
};

type PrepareMsg {
    request: Command;
    commit_number: int;
};

// Represents the state information sent during recovery.
type RecoveryResponseMsg {
    view: int;
    nonce: int;
    log: list<LogEntry>?;
    op_number: int?;
    commit_number: int?;
    sender: Node;
};

role Node {
    // Persistent state
    var self: int = 0;
    var replicas: list<Node> = [];
    var view_number: int = 0;
    var log: list<LogEntry> = [];

    // State machine state
    var kv_store: map<string, string> = {};
    var applied_op_count: int = 0;
    
    // Concurrency state
    var pending_requests: map<int, chan<ClientResponse>> = {};

    // Volatile state
    var status: int = 0;
    // 0: normal, 1: view-change, 2: recovering
    var op_number: int = 0;
    var commit_number: int = 0;
    var normal_view: int = 0;
    var prepare_ok_counts: map<int, int> = {};
    var prepare_buffer: map<int, PrepareMsg> = {};

    var start_view_change_senders: map<Node, bool> = {};
    var do_view_change_senders: map<Node, bool> = {};
    var do_view_change_messages: list<DoViewChangeMsg> = [];
    
    var recovery_nonce: int = 0;
    var recovery_responses: list<RecoveryResponseMsg> = [];
    var recovery_response_senders: map<Node, bool> = {};
    
    func Init(me: int, peers: list<Node>) {
        self = me;
        for var i: int = 0; i < len(peers); i = i + 1 {
            replicas = append(replicas, peers[i]);
        }
    }

    func RecoverInit(me: int, peers: list<Node>) {
        status = 2;
        self = me;
        for var i: int = 0; i < len(peers); i = i + 1 {
          replicas = append(replicas, peers[i]);
        }

        recovery_nonce = recovery_nonce + 1;

        // Clear state from any previous recovery attempts
        recovery_responses = [];
        recovery_response_senders = {};

        var checkpoint_op: int = applied_op_count;

        for var i: int = 0; i < len(replicas); i = i + 1 {
            if (i != self) {
                replicas[i]->Recovery(replicas[self], recovery_nonce, checkpoint_op);
            }
        }
    }

    // Async helper to resolve channels from sync functions
    func send_async(ch: chan<ClientResponse>, resp: ClientResponse) {
        send(ch, resp);
    }

    sync func primary_of(v: int) -> Node {
        var num_servers: int = len(replicas);
        return replicas[v % num_servers];
    }
    
    sync func f() -> int {
        var num_servers: int = len(replicas);
        return (num_servers - 1) / 2;
    }

    // Applies committed entries to the KV store
    sync func apply_committed_entries() {
        for ; applied_op_count < commit_number and applied_op_count < len(log) ; {
            var i: int = applied_op_count;
            var op_n: int = i + 1;
            var entry: LogEntry = log[i];
            var cmd: Command = entry.op;

            var result: string? = nil;

            if (cmd.kind == 1) { // Write
                kv_store = kv_store[cmd.key] := cmd.value!;
            } else if (cmd.kind == 0) { // Read
                if (exists(kv_store, cmd.key)) {
                    result = kv_store[cmd.key];
                } else {
                    println("Read of an unwritten key.");
                }
            } else {
                println("Impossible!");
            }

            if (exists(pending_requests, op_n)) {
                // Resolve with a success status, the read result, and self as primary.
                var resp: ClientResponse = ClientResponse{
                    is_primary: true,
                    key: cmd.key,
                    value: result,
                    primary: replicas[self]
                };
                send_async(pending_requests[op_n], resp);
                pending_requests = erase(pending_requests, op_n);
            }

            applied_op_count = applied_op_count + 1;
        }
    }

    func Prepare(other_view: int, other_request: Command, other_op_number: int, other_commit_number: int) {
        if (other_view != view_number) { return (); }
        if (status != 0) { return (); }
        if (other_op_number <= op_number) { return (); }
        if (!exists(prepare_buffer, other_op_number)) {
            prepare_buffer = prepare_buffer[other_op_number] := PrepareMsg {
                request: other_request,
                commit_number: other_commit_number
            };
        }
        for ; exists(prepare_buffer, op_number + 1); {
            var next_op: int = op_number + 1;
            var msg: PrepareMsg = prepare_buffer[next_op];
            // process_entry(next_op, msg);

            op_number = next_op;
            log = append(log, LogEntry{ view: view_number, op: msg.request });
            if (msg.commit_number > commit_number) {
                commit_number = msg.commit_number;
                apply_committed_entries();
            }
            primary_of(view_number)->PrepareOK(view_number, op_number, replicas[self]);

            prepare_buffer = erase(prepare_buffer, next_op);
        }
    }

    func PrepareOK(other_view: int, other_op_number: int, other_replica_id: Node) {
        var current_primary: Node = primary_of(view_number);
        if (replicas[self] == current_primary and other_view == view_number and status == 0) {
            if (!exists(prepare_ok_counts, other_op_number)) {
                prepare_ok_counts = prepare_ok_counts[other_op_number] := 0;
            }
            prepare_ok_counts = prepare_ok_counts[other_op_number] := prepare_ok_counts[other_op_number] + 1;
            var quorum: int = f() + 1;
            if (prepare_ok_counts[other_op_number] >= quorum and other_op_number > commit_number) {
                commit_number = other_op_number;
                apply_committed_entries();
                for var i: int = 0; i < len(replicas); i = i + 1 {
                    if (i != self) {
                        <-replicas[i]->Commit(view_number, commit_number);
                    }
                }
            }
        }
    }
    func Commit(other_view: int, other_commit_number: int) {
        if (other_view == view_number and status == 0 and other_commit_number > commit_number) {
            commit_number = other_commit_number;
            apply_committed_entries();
        }
    }

    sync func enter_view_change(new_view: int) {
        status = 1;
        view_number = new_view;

        var new_primary: Node = primary_of(new_view);
        var resp: ClientResponse = ClientResponse{
            is_primary: false,
            key: nil,
            value: nil,
            primary: new_primary 
        };

        for (op_n, ch) in pending_requests {
            send_async(ch, resp);
        }
        pending_requests = {};
        
        start_view_change_senders = {};
        start_view_change_senders = start_view_change_senders[replicas[self]] := true; 
        
        do_view_change_senders = {};
        do_view_change_messages = [];

        prepare_ok_counts = {};
        prepare_buffer = {};
    }

    sync func enter_normal_mode(v: int, new_log: list<LogEntry>, op_n: int, commit_n: int) {
        status = 0;
        view_number = v;
        log = new_log;
        op_number = op_n;
        commit_number = commit_n;
        normal_view = v;

        start_view_change_senders = {};
        do_view_change_senders = {};
        do_view_change_messages = [];
        
        prepare_ok_counts = {};
        prepare_buffer = {};
        
        var new_primary: Node = primary_of(v);
        var resp: ClientResponse = ClientResponse{
            is_primary: false,
            key: nil,
            value: nil,
            primary: new_primary 
        };
        for (op_n, ch) in pending_requests {
            send_async(ch, resp);
        }
        pending_requests = {}; 
        
        apply_committed_entries();
    }

    func StartViewChange(new_view: int, replica_id: Node) {
        if (status == 2) {
            return ();
        }

        if (new_view > view_number) {
            enter_view_change(new_view);
            for var i: int = 0; i < len(replicas); i = i + 1 {
                if (i != self) {
                    replicas[i]->StartViewChange(view_number, replicas[self]);
                }
            }
        } else if (new_view == view_number and status == 1) {
            if (exists(start_view_change_senders, replica_id)) {
                return (); // Already have a message from this sender
            }
            start_view_change_senders = start_view_change_senders[replica_id] := true;
            
            var f_val: int = (len(replicas) - 1) / 2;
            var quorum: int = f_val + 1;

            if (len(start_view_change_senders) == quorum) {
                var new_primary: Node = primary_of(view_number);
                
                // Pass our own ID (replicas[self]) as the sender
                new_primary->DoViewChange(view_number, log, normal_view, op_number, commit_number, replicas[self]);
            }
        }
    }

    func DoViewChange(new_view: int, sender_log: list<LogEntry>, sender_normal_view: int, sender_op_number: int, sender_commit_number: int, sender_id: Node) {
        var current_primary: Node = primary_of(new_view);
        
        if (replicas[self] == current_primary and new_view == view_number and status == 1) {
            
            if (exists(do_view_change_senders, sender_id)) {
                return ();
            }
            do_view_change_senders = do_view_change_senders[sender_id] := true;
            
            do_view_change_messages = append(do_view_change_messages, DoViewChangeMsg{
                log: sender_log,
                normal_view: sender_normal_view,
                op_number: sender_op_number,
                commit_number: sender_commit_number
            });

            var quorum: int = f() + 1;
            
            if (len(do_view_change_senders) == quorum) {
                
                var first_msg: DoViewChangeMsg = do_view_change_messages[0];
                var best_log: list<LogEntry> = first_msg.log;
                var best_normal_view: int = first_msg.normal_view;
                var best_op_number: int = first_msg.op_number;
                var max_commit_number: int = first_msg.commit_number;

                for var i: int = 1; i < len(do_view_change_messages); i = i + 1 { // Start from 1
                    var msg: DoViewChangeMsg = do_view_change_messages[i];
                    if (msg.normal_view > best_normal_view) {
                        best_normal_view = msg.normal_view;
                        best_op_number = msg.op_number;
                        best_log = msg.log;
                    } else if (msg.normal_view == best_normal_view and msg.op_number > best_op_number) {
                        best_op_number = msg.op_number;
                        best_log = msg.log;
                    }
                    if (msg.commit_number > max_commit_number) {
                        max_commit_number = msg.commit_number;
                    }
                }
                enter_normal_mode(new_view, best_log, best_op_number, max_commit_number);
                for var i = 0; i < len(replicas); i = i + 1 {
                    replicas[i]->StartView(view_number, log, op_number, commit_number);
                }
            }
        }
    }

    func StartView(new_view: int, new_log: list<LogEntry>, new_op_number: int, new_commit_number: int) {
        if (status == 2) {
            return ();
        }
        if (new_view >= view_number) {
            enter_normal_mode(new_view, new_log, new_op_number, new_commit_number);
            var new_primary: Node = primary_of(view_number);
            if (replicas[self] != new_primary) {
                for var i = commit_number + 1; i <= op_number; i = i + 1 {
                    new_primary->PrepareOK(view_number, i, replicas[self]);
                }
            }
        }
    }

    func Recovery(replica_id: Node, nonce: int, checkpoint_op: int) {
        // Only respond if status is normal
        if (status != 0) {
            return ();
        }

        var current_primary: Node = primary_of(view_number);

        if (replicas[self] == current_primary) {
            // This node is the primary. Send the full state.

            // Find the log suffix after the recovering node's last checkpoint
            var log_suffix: list<LogEntry> = [];
            for var i = checkpoint_op; i < len(log); i = i + 1 {
                log_suffix = append(log_suffix, log[i]);
            }

            // Send the response with the log and current numbers
            replica_id->RecoveryResponse(view_number, nonce, log_suffix, op_number, commit_number, replicas[self]);

        } else {
            // This node is a backup. Send a response with nil state.
            replica_id->RecoveryResponse(view_number, nonce, nil, nil, nil, replicas[self]);
        }
    }

    func RecoveryResponse(other_view: int, other_nonce: int, other_log: list<LogEntry>?, other_op_number: int?, other_commit_number: int?, sender_id: Node) {
        if (status != 2) {
            return ();
        }
        if (other_nonce != recovery_nonce) {
            return ();
        }

        // Ignore duplicate responses from the same sender
        if (exists(recovery_response_senders, sender_id)) {
            return ();
        }

        // Store the response
        recovery_response_senders = recovery_response_senders[sender_id] := true;
        recovery_responses = append(recovery_responses, RecoveryResponseMsg {
            view: other_view,
            nonce: other_nonce,
            log: other_log,
            op_number: other_op_number,
            commit_number: other_commit_number,
            sender: sender_id
        });

        // Check if we have a quorum of f+1 responses
        var quorum: int = f() + 1;
        if (len(recovery_response_senders) < quorum) {
            return (); // Not enough responses yet
        }


        // 1. Find the latest view number seen in the responses
        var latest_view: int = -1;
        for var i = 0; i < len(recovery_responses); i = i + 1 {
            if (recovery_responses[i].view > latest_view) {
                latest_view = recovery_responses[i].view;
            }
        }

        if (latest_view == -1) {
            return (); // Should not happen
        }

        var latest_view_primary: Node = primary_of(latest_view);

        var primary_resp: RecoveryResponseMsg? = nil;
        for var i = 0; i < len(recovery_responses); i = i + 1 {
            var resp: RecoveryResponseMsg = recovery_responses[i];
            if (resp.view == latest_view and resp.sender == latest_view_primary) {
                primary_resp = resp;
                break;
            }
        }

        if (primary_resp == nil) {
            return ();
        }

        var p_resp: RecoveryResponseMsg = primary_resp!;

        if (p_resp.log == nil or p_resp.op_number == nil or p_resp.commit_number == nil) {
            println("Recovery failed: Primary sent nil state.");
            return ();
        }

        // Update our state using the primary's information
        view_number = p_resp.view;
        commit_number = p_resp.commit_number!;
        op_number = p_resp.op_number!;

        // Reconstruct the log: our local prefix + primary's suffix
        var new_log: list<LogEntry> = [];
        for var i = 0; i < applied_op_count; i = i + 1 {
            new_log = append(new_log, log[i]);
        }
        // Append the suffix from the primary
        var log_suffix: list<LogEntry> = p_resp.log!;
        for var i = 0; i < len(log_suffix); i = i + 1 {
            new_log = append(new_log, log_suffix[i]);
        }
        log = new_log;

        status = 0;

        recovery_responses = [];
        recovery_response_senders = {};

        apply_committed_entries();

        // Send PrepareOK for non-committed ops to new primary
        var new_primary: Node = primary_of(view_number);
        if (replicas[self] != new_primary) {
            for var i = commit_number + 1; i <= op_number; i = i + 1 {
                new_primary->PrepareOK(view_number, i, replicas[self]);
            }
        }
    }

    // Accepts a new command, logs it, and starts the replication process.
    sync func NewEntry(cmd: Command) -> chan<ClientResponse> {
        var current_primary: Node = primary_of(view_number);
        if (replicas[self] != current_primary) {
            // Not the primary. Return a failure/redirect response.
            var p_err: chan<ClientResponse> = make(1);
            var resp: ClientResponse = ClientResponse{
                is_primary: false,
                key: nil,
                value: nil,
                primary: current_primary 
            };
            send_async(p_err, resp);
            return p_err;
        }
        if (status != 0) {
            var p_err: chan<ClientResponse> = make(1);
            var resp: ClientResponse = ClientResponse{
                is_primary: false,
                key: nil,
                value: nil,
                primary: current_primary 
            };
            send_async(p_err, resp);
            return p_err;
        }

        op_number = op_number + 1;
        log = append(log, LogEntry{view: view_number, op: cmd});
        prepare_ok_counts = prepare_ok_counts[op_number] := 0;

        // Create a promise for the client to await commitment
        var p: chan<ClientResponse> = make(1);
        pending_requests = pending_requests[op_number] := p;

        if (len(replicas) == 1) {
            commit_number = op_number;
            apply_committed_entries(); // This will resolve the promise
        } else {
             for var i = 0; i < len(replicas); i = i + 1 {
                if (i != self) {
                    // Replicate the command
                    replicas[i]->Prepare(view_number, cmd, op_number, commit_number);
                }
            }
        }
        
        // Return the future associated with the promise
        return p;
    }

    // Accepts a new Write command from a client.
    func Write(key: string, value: string) -> ClientResponse {
        var cmd: Command = Command{ kind: 1, key: key, value: value };
        var response: chan<ClientResponse> = NewEntry(cmd);
        return <- response;
    }

    // Accepts a new Read command from a client.
    func Read(key: string) -> ClientResponse {
        // A Read is also a log entry to ensure linearizability
        var cmd: Command = Command{ kind: 0, key: key, value: nil };
        return <- NewEntry(cmd);
    }
    
    func SimulateTimeout() {
        if (status == 2) { 
            return (); 
        }

        var current_primary: Node = primary_of(view_number);
        if (replicas[self] != current_primary) { 
            enter_view_change(view_number + 1);
            for var i = 0; i < len(replicas); i = i + 1 {
                 if (i != self) {
                    replicas[i]->StartViewChange(view_number, replicas[self]);
                 }
            }
        }
    }

    func GetKVStore() -> map<string, string> {
        return kv_store;
    }
}

ClientInterface {
    var responses: list<(ClientResponse, string)> = [];

    // Sends a new write command to a specific replica, retrying on redirect.
    func Write(dest: Node, key: string, value: string) {
        var current_target: Node = dest;

        for ;; {
            var resp: ClientResponse = <- current_target->Write(key, value);

            if (resp.is_primary == true) {
                responses = append(responses, (resp, key));
                return ();
            }
            current_target = resp.primary;
        }
    }

    // Sends a new read command to a specific replica, retrying on redirect.
    func Read(dest: Node, key: string) -> string? {
        var current_target: Node = dest;

        for ;; {
            var resp: ClientResponse = <- current_target->Read(key);

            if (resp.is_primary == true) {
                return resp.value;
            }
            current_target = resp.primary;
        }

        return nil;
    }

    // Gets the entire KV store from a replica (for debugging/testing).
    func GetKVStore(dest: Node) -> map<string, string> {
        return <-dest->GetKVStore();
    }

    // Triggers a simulated timeout at the destination node.
    func SimulateTimeout(dest: Node) {
        dest->SimulateTimeout();
    }
}