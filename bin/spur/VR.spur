type Command {
    kind: int; // 0: Read, 1: Write
    key: string;
    value: string?;
};

// Represents a single entry in a replica's log.
type LogEntry {
    view: int;
    op: Command;
};
// Represents the state information sent during a view change.
type DoViewChangeMsg {
    log: list<LogEntry>;
    normal_view: int;
    op_number: int;
    commit_number: int;
};

type ClientResponse {
    is_primary: bool;
    value: string?;
    primary: Node;
};

type PrepareMsg {
    request: Command;
    commit_number: int;
};

role Node {
    // Persistent state
    var self: int = 0;
    var replicas: list<Node> = [];
    var view_number: int = 0;
    var log: list<LogEntry> = [];

    // State machine state
    var kv_store: map<string, string> = {};
    var applied_op_count: int = 0;
    
    // Concurrency state
    var pending_requests: map<int, promise<ClientResponse>> = {};

    // Volatile state
    var status: int = 0;
    // 0: normal, 1: view-change, 2: recovering
    var op_number: int = 0;
    var commit_number: int = 0;
    var normal_view: int = 0;
    var prepare_ok_counts: map<int, int> = {};
    var prepare_buffer: map<int, PrepareMsg> = {};

    var start_view_change_count: int = 0;
    var do_view_change_count: int = 0;
    var do_view_change_messages: list<DoViewChangeMsg> = [];
    var recovery_response_count: int = 0;
    
    func Init(me: int, peers: list<Node>) {
        self = me;
        for (var i: int = 0; i < len(peers); i = i + 1) {
            replicas = append(replicas, peers[i]);
        }
    }

    sync func primary_of(v: int) -> Node {
        var num_servers: int = len(replicas);
        return replicas[v % num_servers];
    }
    
    sync func f() -> int {
        var num_servers: int = len(replicas);
        return (num_servers - 1) / 2;
    }

    // Applies committed entries to the KV store
    sync func apply_committed_entries() {
        for (; applied_op_count < commit_number and applied_op_count < len(log) ;) {
            var i: int = applied_op_count;
            var op_n: int = i + 1; 
            var entry: LogEntry = log[i];
            var cmd: Command = entry.op;
            
            var result: string? = nil;
            
            if (cmd.kind == 1) { // Write
                kv_store[cmd.key] = cmd.value!;
            } elseif (cmd.kind == 0) { // Read
                if (exists(kv_store, cmd.key)) {
                    result = kv_store[cmd.key];
                }
            }

            if (exists(pending_requests, op_n)) {
                // Resolve with a success status, the read result, and self as primary.
                var resp: ClientResponse = ClientResponse{
                    is_primary: true, 
                    value: result, 
                    primary: replicas[self]
                };
                resolve_promise(pending_requests[op_n], resp);
                erase(pending_requests, op_n);
            }
            
            applied_op_count = applied_op_count + 1;
        }
    }

    func process_entry(op_n: int, msg: PrepareMsg) {
        op_number = op_n;
        log = append(log, LogEntry{ view: view_number, op: msg.request });
        rpc_call(primary_of(view_number), PrepareOK(view_number, op_number, replicas[self]));
        if (msg.commit_number > commit_number) {
            commit_number = msg.commit_number;
            apply_committed_entries();
        }
    }
    
    func drain_buffer() {
        for (; exists(prepare_buffer, op_number + 1); ) {
            var next_op: int = op_number + 1;
            var msg: PrepareMsg = prepare_buffer[next_op];
            process_entry(next_op, msg);  
            erase(prepare_buffer, next_op);
        }
    }
    
    func Prepare(other_view: int, other_request: Command, other_op_number: int, other_commit_number: int) {
        if (other_view != view_number) { return (); }
        if (other_op_number <= op_number) { return (); }
        if (!exists(prepare_buffer, other_op_number)) {
            prepare_buffer[other_op_number] = PrepareMsg {
                request: other_request,
                commit_number: other_commit_number
            };
        }
        @drain_buffer();
    }

    func PrepareOK(other_view: int, other_op_number: int, other_replica_id: Node) {
        var current_primary: Node = primary_of(view_number);
        if (replicas[self] == current_primary and other_view == view_number) {
            if (!exists(prepare_ok_counts, other_op_number)) {
                prepare_ok_counts[other_op_number] = 0;
            }
            prepare_ok_counts[other_op_number] = prepare_ok_counts[other_op_number] + 1;
            var mid: int = f();
            if (prepare_ok_counts[other_op_number] >= mid and other_op_number > commit_number) {
                commit_number = other_op_number;
                apply_committed_entries();
                for (var i: int = 0; i < len(replicas); i = i + 1) {
                    if (i != self) {
                        rpc_call(replicas[i], Commit(view_number, commit_number));
                    }
                }
            }
        }
    }
    func Commit(other_view: int, other_commit_number: int) {
        if (other_view == view_number and other_commit_number > commit_number) {
            commit_number = other_commit_number;
            apply_committed_entries();
        }
    }

    sync func enter_view_change(new_view: int) {
        status = 1;
        view_number = new_view;
        start_view_change_count = 1;
        do_view_change_count = 0;
        do_view_change_messages = [];
    }
    
    sync func enter_normal_mode(v: int, new_log: list<LogEntry>, op_n: int, commit_n: int) {
        status = 0;
        view_number = v;
        log = new_log;
        op_number = op_n;
        commit_number = commit_n;
        normal_view = v;
        do_view_change_count = 0;
        do_view_change_messages = [];
        
        kv_store = {};
        applied_op_count = 0;
        pending_requests = {}; 
        apply_committed_entries();
    }

    func StartViewChange(new_view: int, replica_id: Node) {
        if (new_view > view_number) {
            enter_view_change(new_view);
            for (var i: int = 0; i < len(replicas); i = i + 1) {
                 if (i != self) {
                    rpc_call(replicas[i], StartViewChange(view_number, replicas[self]));
                 }
            }
        } elseif (new_view == view_number and status == 1) {
            start_view_change_count = start_view_change_count + 1;
            var f_val: int = (len(replicas) - 1) / 2;
            var quorum: int = f_val + 1;
            if (start_view_change_count == quorum) {
                var new_primary: Node = primary_of(view_number);
                rpc_call(new_primary, DoViewChange(view_number, log, normal_view, op_number, commit_number));
            }
        }
    }

    func DoViewChange(new_view: int, sender_log: list<LogEntry>, sender_normal_view: int, sender_op_number: int, sender_commit_number: int) {
        var current_primary: Node = primary_of(new_view);
        if (replicas[self] == current_primary and new_view == view_number) {
            do_view_change_count = do_view_change_count + 1;
            do_view_change_messages = append(do_view_change_messages, DoViewChangeMsg{
                log: sender_log,
                normal_view: sender_normal_view,
                op_number: sender_op_number,
                commit_number: sender_commit_number
            });
            var quorum: int = f() + 1;
            if (do_view_change_count == quorum) {
                var best_log: list<LogEntry> = log;
                var best_normal_view: int = normal_view;
                var best_op_number: int = op_number;
                var max_commit_number: int = commit_number;
                for (var i: int = 0; i < len(do_view_change_messages); i = i + 1) {
                    var msg: DoViewChangeMsg = do_view_change_messages[i];
                    if (msg.normal_view > best_normal_view) {
                        best_normal_view = msg.normal_view;
                        best_op_number = msg.op_number;
                        best_log = msg.log;
                    } elseif (msg.normal_view == best_normal_view and msg.op_number > best_op_number) {
                        best_op_number = msg.op_number;
                        best_log = msg.log;
                    }
                    if (msg.commit_number > max_commit_number) {
                        max_commit_number = msg.commit_number;
                    }
                }
                enter_normal_mode(new_view, best_log, best_op_number, max_commit_number);
                for (var i: int = 0; i < len(replicas); i = i + 1) {
                    rpc_call(replicas[i], StartView(view_number, log, op_number, commit_number));
                }
            }
        }
    }
    func StartView(new_view: int, new_log: list<LogEntry>, new_op_number: int, new_commit_number: int) {
        if (new_view >= view_number) {
            enter_normal_mode(new_view, new_log, new_op_number, new_commit_number);
            var new_primary: Node = primary_of(view_number);
            if (replicas[self] != new_primary) {
                for (var i: int = commit_number + 1; i <= op_number; i = i + 1) {
                    rpc_call(new_primary, PrepareOK(view_number, i, replicas[self]));
                }
            }
        }
    }

    // Empty stubs
    func Recovery(replica_id: Node, nonce: int) {}
    func RecoveryResponse(nonce: int, view: int, log: list<LogEntry>, op_number: int, commit_number: int) {}

    // Accepts a new command, logs it, and starts the replication process.
    func NewEntry(cmd: Command) -> future<ClientResponse> {
        var current_primary: Node = primary_of(view_number);
        if (replicas[self] != current_primary) {
            // Not the primary. Return a failure/redirect response.
            var p_err: promise<ClientResponse> = create_promise();
            var resp: ClientResponse = ClientResponse{
                is_primary: false,
                value: nil,
                primary: current_primary 
            };
            resolve_promise(p_err, resp); 
            return create_future(p_err);
        }

        op_number = op_number + 1;
        log = append(log, LogEntry{view: view_number, op: cmd});
        prepare_ok_counts[op_number] = 0;

        // Create a promise for the client to await commitment
        var p: promise<ClientResponse> = create_promise();
        pending_requests[op_number] = p;

        if (len(replicas) == 1) {
            commit_number = op_number;
            apply_committed_entries(); // This will resolve the promise
        } else {
             for (var i: int = 0; i < len(replicas); i = i + 1) {
                if (i != self) {
                    // Replicate the command
                    rpc_call(replicas[i], Prepare(view_number, cmd, op_number, commit_number));
                }
            }
        }
        
        // Return the future associated with the promise
        return create_future(p);
    }


    // Accepts a new Write command from a client.
    func Write(key: string, value: string) -> future<ClientResponse> {
        var cmd: Command = Command{ kind: 1, key: key, value: value };
        return @NewEntry(cmd);
    }

    // Accepts a new Read command from a client.
    func Read(key: string) -> future<ClientResponse> {
        // A Read is also a log entry to ensure linearizability
        var cmd: Command = Command{ kind: 0, key: key, value: nil };
        return @NewEntry(cmd);
    }

    func Tick() {
        var current_primary: Node = primary_of(view_number);
        if (replicas[self] == current_primary) {
            for (var i: int = 0; i < len(replicas); i = i + 1) {
                if (i != self) {
                    rpc_call(replicas[i], Commit(view_number, commit_number));
                }
            }
        }
    }
    
    func SimulateTimeout() {
        var current_primary: Node = primary_of(view_number);
        if (replicas[self] != current_primary) { 
            enter_view_change(view_number + 1);
            for (var i: int = 0; i < len(replicas); i = i + 1) {
                 if (i != self) {
                    rpc_call(replicas[i], StartViewChange(view_number, replicas[self]));
                 }
            }
        }
    }

    func GetKVStore() -> map<string, string> {
        return kv_store;
    }
}

ClientInterface {
    // Initializes a replica node.
    func init(dest: int, replicas: list<Node>) {
        rpc_call(replicas[dest], Init(dest, replicas));
    }

    // Sends a new write command to a specific replica, retrying on redirect.
    func write(dest: Node, key: string, value: string) {
        var current_target: Node = dest;

        for (;;) {
            // Await the RPC, then await the commit future
            var resp: ClientResponse = @@rpc_call(current_target, Write(key, value));
            
            if (resp.is_primary == true) {
                // 0 = OK. The write is committed.
                break;
            } elseif (resp.is_primary == true) {
                // 1 = NotPrimary. Update target and retry.
                current_target = resp.primary;
            }
            // Loop continues and retries with the new target
        }
    }

    // Sends a new read command to a specific replica, retrying on redirect.
    func read(dest: Node, key: string) -> string? {
        var current_target: Node = dest;

        for (;;) {
            // Await the RPC, then await the commit future
            var resp: ClientResponse = @@rpc_call(current_target, Read(key));

            if (resp.is_primary == true) {
                return resp.value;
            } elseif (resp.is_primary == true) {
                current_target = resp.primary;
            }
            // Loop continues and retries with the new target
        }

        return nil;
    }

    // Gets the entire KV store from a replica (for debugging/testing).
    func getKVStore(dest: Node) -> map<string, string> {
        return @rpc_call(dest, GetKVStore());
    }

    // Triggers a simulated timeout at the destination node.
    func simulateTimeout(dest: Node) {
        rpc_call(dest, SimulateTimeout());
    }
}