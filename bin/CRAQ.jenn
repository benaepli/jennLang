Node {
    string role = "";
    map<Key, Value> db = {};
    map<Key, bool> is_committed = {};
    int predecessor = 0;
    int successor = 0;
    int head = 0;
    int tail = 0;

    func Read(key) -> Value {
        if ((role == "Head") || (role == "Mid")) {
            if (!is_committed[key]) {
                return rpc_call(tail, Read(key));
            } else {
                return db[key];
            }
        } else {
            return db[key];
        }
    }

    func Write(key, value) -> none {
        if ((role == "Head") || (role == "Mid")) {
            db[key] = value;
            is_committed[key] = false;
            rpc_async_call(successor, Write(key, value));
            await is_committed[key] == true;
            rpc_async_call(predecessor, AckWrite(key, value));
        } else {
            // role == "Tail"
            db[key] = value;
            is_committed[key] = true;
        }
    }
    
    func AckWrite(key, value) -> none {
        is_committed[key] = true;
    }
    
    func TriggerFailover(failed_node, failed_node_pred, failed_node_succ, new_tail) -> none {
        if (failed_node == successor) {
            successor = failed_node_succ;
            dirty_logs = {};
            for (key, committed in is_committed) {
                if (!committed) {
                    dirty_logs[key] = db[key];
                }
            }
            rpc_call(successor, PropagateDirtyLogs(dirty_logs));
        }
        if (failed_node == predecessor) {
            predecessor = failed_node_pred;
            clean_logs = {};
            for (key, committed in is_committed) {
                if (committed) {
                    clean_logs[key] = db[key];
                }
            }
            rpc_call(predecessor, BackPropagateCleanLogs(clean_logs));
        }

        tail = new_tail;
        if (role == "Tail") {
            role = "Mid";
            successor = tail;
            rpc_call(tail, PropagateLogsToTail(db));
        }
    }
    func Init(assigned_role, pred, succ, h, t, data) -> none {
        role = assigned_role;
        predecessor = pred;
        successor = succ;
        head = h;
        tail = t;
        db = {};

        for (key, value in data) {
            db[key] = value;
        }
    }
    // Receiving dirty logs
    func PropagateDirtyLogs(dirty_logs) -> none {
        diff_dirty_logs = {};
        for (key, value in dirty_logs) {
            // previous value is committed, but hasn't seen new version yet.
            if ((value != db[key]) && (true == is_committed[key])) {
                db[key] = value;
                if ("Tail" != role) {
                    rpc_async_call(successor, Write(key, value));
                }
            }
        }
    }

    func BackPropagateCleanLogs(clean_logs) -> none {
        diff_clean_logs = {};
        for (key, value in clean_logs) {
            if ((value == db[key]) && (false == is_committed[key])) {
                is_committed[key] = true;
                if ("Head" != role) {
                    rpc_async_call(predecessor, AckWrite(key, value));
                }
            }
        }
    }

    
    func PropagageLogsToTail(other_db) -> none {
        if (role == "Tail") {
            for (key, value in other_db) {
                db[key] = value;
            }
        } 
    }
}

ClientInterface { 
    
    func read(dest, key) -> int {
        val = rpc_call(dest, Read(key));
        return val;
    }

    func write(key, val) -> none {
        dest = head;
        rpc_call(dest, Write(key, val));
    }

	func triggerFailover(dest, failed_node, new_tail) -> none {
        rpc_call(dest, TriggerFailover(failed_node, new_tail));
    }

    func init_head(dest, succ, t, data) -> none {
        rpc_call(dest, Init("Head", dest, succ, dest, t, data));
    }

    func init_tail(dest, pred, h, data) -> none {
        rpc_call(dest, Init("Tail", pred, dest, h, dest, data));
    }

    func init_mid(dest, pred, succ, h, t, data) -> none {
        rpc_call(dest, Init("Mid", pred, succ, h, t, data));
    }
}